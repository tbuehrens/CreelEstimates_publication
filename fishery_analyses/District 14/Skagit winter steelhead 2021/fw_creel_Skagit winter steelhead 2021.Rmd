---
title: "Freshwater Creel Estimates"
date: "`r Sys.Date()`"
params:
  project_name: "District 14"
  fishery_name: "Skagit winter steelhead 2021"
  est_date_start: "2021-02-01"
  est_date_end: "2021-04-13"
  est_catch_groups: !r data.frame(
    rbind(c(species = 'Steelhead', life_stage = 'NA', fin_mark = 'UM', fate = 'Released'))
    )
  person_count_type: "angler"
  period_pe: "week"
  period_bss: "day"
  days_wkend: !r c('Saturday', 'Sunday')
  index_count_types: "Vehicle/Trailers Only"
  census_expansion: "Direct"
  day_length_expansion: "night closure"
  min_fishing_time: 0.5
  output_location_filepath: "local"
output:
  html_document:
    fig_caption: yes
    theme: default
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
#running the 'setup' chunk loads the read-only `params` list
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.width = 10, fig.height = 8)
library("here") #defines root at working dir of .Rproj
```

```{r first_time_run, eval=FALSE, include=FALSE}
# set up file paths
## top level for scripts and outputs
# if (!dir.exists(here("fishery_analyses"))) {
#   dir.create(here("fishery_analyses")); "fishery_analyses folder created"
# }
# ## project level
# if (!dir.exists(here("fishery_analyses", params$project_name))) {
#   dir.create(here("fishery_analyses", params$project_name))
#   paste(here("fishery_analyses", params$project_name), "folder created")
# }
# ## fishery-specific
# if (!dir.exists(here("fishery_analyses", params$project_name, params$fishery_name))) {
#   dir.create(here("fishery_analyses", params$project_name, params$fishery_name))
#   paste(here("fishery_analyses", params$project_name, params$fishery_name), "folder created")
# }
# 
# # evaluate if analysis .Rmd already exists, if not then generate new file 
# if (file.exists(here("fishery_analyses", params$project_name, params$fishery_name, 
#        paste0("fw_creel_", params$fishery_name, ".Rmd")))) {
#   
#   print("Analysis .Rmd file already exists")
#   
# } else {
# #save the master template with new params arguments for the fishery
# rstudioapi::documentSave(rstudioapi::getActiveDocumentContext()$id)
# #make an appropriately renamed copy
# file.copy(
#   here("template_scripts/fw_creel.Rmd"),
#   here("fishery_analyses", params$project_name, params$fishery_name, 
#        paste0("fw_creel_", params$fishery_name, ".Rmd"))
# )
# #open the new copy
# rstudioapi::documentOpen(
#   here("fishery_analyses", params$project_name, params$fishery_name, 
#        paste0("fw_creel_", params$fishery_name, ".Rmd"))
# )
# }

```

```{r packages_and_functions}
library("suncalc")
library("tidyverse")
library("patchwork")
library("gt")
library("gridExtra")
theme_set(theme_light())

library("rstan")
rstan_options(auto_write = TRUE)

purrr::walk(list.files(here("R_functions"), full.names = T), source)
```

# `r paste(params$fishery_name)`

```{r}
gt(tibble(param = names(params), value = as.character(params)))
```

# Set day length times if using manual option 

```{r day_length_inputs, echo = FALSE}

day_length_inputs <- list()

if(params$day_length_expansion == "manual"){
# Step #1: Select general strategy for [earliest] start and [latest] end time
    day_length_inputs$start_time<-c("manual") # enter either "sunrise" or "manual" 
    day_length_inputs$end_time<-c("sunset")    # enter either "sunset"  or "manual" 
  # Step #2A: If necessary, specify an offset (in hours) to the start and end times
    # (e.g., if legal fishing occurs 1 hr. prior to sunrise & sunset, enter 1 below for both); enter 0 if no offset needed
    day_length_inputs$start_adj<-c(1) # Specify an offset for the start time (in hours);    
    day_length_inputs$end_adj<-c(1)   # Specify an offset for the end time (in hours);  
  # Step #2B: If "manual" entered for "ui_start_time" or "ui_end_time", enter the earliest start and/or latest end time for a creel survey event
    day_length_inputs$start_manual<-c("06:00:00") # Specify manual start time (format "HH:MM:SS", e.g., 6 AM = "06:00:00")
    day_length_inputs$end_manual<-  c() # Specify manual end time (format "HH:MM:SS")  
}
```

# Fetch raw data

```{r dwg_fetch, echo=FALSE}
if(!file.exists(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("dwg_", params$fishery_name, ".rds")))){
  dwg <- fetch_dwg(params$fishery_name)
  saveRDS(dwg,file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("dwg_", params$fishery_name, ".rds")))
  
}else{
  dwg<-readRDS(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("dwg_", params$fishery_name, ".rds")))
}

dwg$days <- prep_days(
  date_begin = params$est_date_start, 
  date_end = params$est_date_end, 
  weekends = params$days_wkend,
  holidays = read_lines(paste(here(), "input_files/dates_holidays_2015_2030.txt", sep = "/")),
  lat = mean(dwg$ll$centroid_lat), #can/should consider smarter options
  long = mean(dwg$ll$centroid_lon),#can/should consider smarter options 
  period_pe = params$period_pe,
  sections = unique(dwg$effort$section_num),
  closures = dwg$closures,
  day_length = params$day_length_expansion,
  day_length_inputs = day_length_inputs
  )
```

# Review fetched data

## Fishery sections

```{r table_sections}
dwg$effort |> 
  filter(location_type == "Section") |> 
  distinct(water_body, section_num, location) |> 
  arrange(section_num) |>
  select(`Water Body` = water_body, `Section Number` = section_num, `Location description` = location) |> 
  gt()
```

## Days

```{r gt_creel_days}
dwg$days |> 
  mutate(across(starts_with("open_"), ~if_else(., "open","closed"))) |> 
  rename_with(.cols = starts_with("open_"), .fn = ~str_remove_all(., "open_")) |> 
  gt::gt() |> 
  gt::data_color(
    columns = contains("section_"),
    colors = scales::col_factor(
      palette = c("#C3C7C3", "#78B574"),
      domain = c("closed","open")) 
  )

```

## Period-Dates reference
```{r gt_period_dates_reference}

# reference for period (time_strata)

dwg$days |> 
    group_by(period) |> 
    summarise(
      min_event_date = min(event_date),
      max_event_date = max(event_date)) |> 
  gt::gt(caption = "Reference table containing the first and last date within each time stratum period in the monitoring period.")

```

## Effort

```{r gt_creel_effort}
dwg$effort |>
  filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))) |> 
  distinct(section_num, location, event_date, tie_in_indicator, count_sequence) |> 
  count(section_num, location, tie_in_indicator) |> 
  mutate(tie_in_indicator = case_when(
    tie_in_indicator == 1 ~ "census",
    tie_in_indicator == 0 ~ "index"
  )) |>
  arrange(section_num, tie_in_indicator, location) |> 
  gt(groupname_col = "section_num", rowname_col = "location") |> 
  tab_style(
    style = list(cell_fill("grey70"), cell_text(weight = "bold")),
    locations = cells_body(rows = tie_in_indicator == "census")
  )
```

## Interview

```{r gt_creel_interview}
# dwg$interview |>  
#   filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))) |> 
#   count(section_num, fishing_location) |> 
#   arrange(section_num) |> 
#   gt(groupname_col = "section_num", caption = "Number of interviews by analysis section")

dwg$interview |>  
  filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))) |> 
  count(section_num, event_date) |> 
  pivot_wider(names_from = section_num, values_from = n) |> 
  arrange(event_date) |> 
  gt(rowname_col = "event_date") |> 
  sub_missing() |> 
  data_color(
    columns = where(is.numeric),
    colors = scales::col_quantile(
      palette = c("white", "orange"), 
      reverse = T, na.color = "grey",
      domain = NULL #c(0, )
    )
  )
```

## Catch

```{r gt_creel_catch}
dwg$catch |>
  left_join(dwg$interview, by = "interview_id") |> 
  filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))) |> 
  group_by(catch_group) |> 
  summarise(fish_count = sum(fish_count), .groups = "drop") |> 
  gt(caption = "Total reported encounters in interviews to date for catch groups defined as individual combinations of species, life state, fin mark, and fate")
```

# Shared data aggregation

```{r prep_dwg_summ_shared_summary_objects, echo=FALSE, results = 'hide'}
dwg_summ <- list() #intermediate objects wrangled from creel list elements

#get count_type levels from interview to ensure alignment...?

#prep_interview() no longer excludes observations with NA vehicle_count/trailer_count
#requires handling during summarization for fisheries/records where these were not collected
dwg_summ$interview <- prep_dwg_interview(
  dwg_interview = dwg$interview |> filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))),
  dwg_catch = dwg$catch,
  person_count_type = params$person_count_type,
  min_fishing_time = params$min_fishing_time,
  est_catch_groups = params$est_catch_groups 
  )

#Aggregates census (tie in) effort counts, associating to closest-in-time index count
dwg_summ$effort_census <- prep_dwg_effort_census(
  eff = dwg$effort |> filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))))

#Aggregates index effort counts over locations within count_seq & section
dwg_summ$effort_index <- prep_dwg_effort_index(
  eff = dwg$effort |> filter(between(event_date, as.Date(params$est_date_start), as.Date(params$est_date_end))))

```

## Index effort counts

```{r plot_index_effort_counts, fig.cap= "Index effort counts for each count sequence on surveyed days within the monitoring period."}
# plot of index effort counts faceted by section and count_type per count sequence and day 
plot_inputs_pe_index_effort_counts(effort_index = dwg_summ$effort_index)
```

# PE estimation

```{r prep_inputs_pe, results = 'hide'}
inputs_pe <- list()

#derive a table of potentially section-anglerType-specific values to modify census expansions
inputs_pe$census_expan <- prep_inputs_pe_census_expan(eff = dwg$effort, census_expansion = params$census_expansion)

# Calculate total days the fishery was open per strata (strata = period, day_type, and section_num)
inputs_pe$days_total <- prep_inputs_pe_days_total(days = dwg$days)

# depending on the types of index counts, reach the calc: ang_hrs_daily_mean_TI_expan = angler_hours_daily_mean * TI_expan_final
# when index counts are already bank & boat, matching census counts,
#   then angler_hour daily means are just effort index counts of anglers expanded by day length,
#   which are multiplied against tie-in expanded census counts of anglers by type (per section_num)
# but when index counts are trailers & vehicles,
#   then angler_hour daily means require first using interviews to estimate anglers_per_vhcl_trlr by angler_final total & boat 
#   so anglers_per_vhcl_trlr can be multiplied against the trailer & vehicle counts in effort_index, releveled to boat/total
#   and then TI-expanded counts similarly require splitting, re-leveling and rebinding census to boat/total to allow join with effort_index
#   and THEN generating a final object with total, boat and derived-bank, including dealing with case of only-bank (e.g., Cascade)
if(str_detect(params$index_count_types, "Bank|Boat")) {
  
  inputs_pe$ang_hrs_daily_mean <- prep_inputs_pe_ang_hrs_bank_boat(
    days = dwg$days, 
    dwg_summarized = dwg_summ,
    census_expan = inputs_pe$census_expan
    )
  
} else if(str_detect(params$index_count_types, "Vehicle|Trailer")) {
  
  #could skip retaining as list element and just pass as inline call in arg to next function
  inputs_pe$interview_ang_per_vhcl_trlr <- prep_inputs_pe_int_ang_per_vhcl_trlr(dwg_summarized = dwg_summ)
  
  # returns season-long total of counts for paired census and index counts
  inputs_pe$paired_census_index_counts <- prep_inputs_pe_paired_census_index_counts(
  days = dwg$days,
  dwg_summarized = dwg_summ,
  interview_ang_per_vehic = inputs_pe$interview_ang_per_vhcl_trlr,
  census_expan = inputs_pe$census_expan)
  
  # returns census-corrected daily mean angler hours 
  inputs_pe$ang_hrs_daily_mean <- prep_inputs_pe_ang_hrs_vhcl_trlr(
    days = dwg$days, 
    dwg_summarized = dwg_summ,
    interview_ang_per_vehic = inputs_pe$interview_ang_per_vhcl_trlr,
    paired_census_index_counts = inputs_pe$paired_census_index_counts,
    census_expan = inputs_pe$census_expan
    )
  
}

#aggregate interviews per day per strata of [week/month-weekend/day-section_num-bank/boat-est_cg]
#then multiply by TI-expanded effort estimate
#dropping any date-section_num-angler_final-catch_groups for which only interview-based CPUE is available
#but census-corrected effort estimates are not (various reasons why a day-section_num-angler_final hours could be NA)
inputs_pe$daily_cpue_catch_est <- prep_inputs_pe_daily_cpue_catch_est(
  days = dwg$days,
  dwg_summarized = dwg_summ,
  angler_hours_daily_mean = inputs_pe$ang_hrs_daily_mean
)

#THIS SEEMS WRONG/MISSING STRATA:  dplyr::group_by(section_num, angler_final)
inputs_pe$df <- prep_inputs_pe_df(
  days = dwg$days,
  angler_hours_daily_mean = inputs_pe$ang_hrs_daily_mean
)

```

## Paired census and index angler effort count surveys

```{r view_paired_census_index_counts, fig.cap= "Scatterplot displaying the effort bias-term ratio (TI_expan_final) for each section and angler type (angler_final), representing the total count from census surveys divided by the total count from index surveys. A 1:1 relationship is shown by the dashed line." }

# table view of census / index surveys and resulting bias term ratio 
inputs_pe$paired_census_index_counts |> 
  select(section_num, angler_final, count_census, count_index, TI_expan_final) |> 
  gt(caption = "The season-long sum of paired census and index angler effort counts and corresponding bias-term ratio (TI_expan_final), indicating the magnitude and direction (postive or negative) of bias in index counts relative to census counts") |> 
  fmt_number(count_index, decimals = 0) |> 
  fmt_number(TI_expan_final, decimals = 2)

# scatterplot of total census counts vs. total index counts by angler type and section 
plot_inputs_pe_census_vs_index(census_TI_expan = inputs_pe$paired_census_index_counts)

```


```{r estimates_pe}
estimates_pe <- list() 

estimates_pe$effort <- est_pe_effort(
  days = dwg$days,
  pe_inputs_list = inputs_pe
)

estimates_pe$catch <- est_pe_catch(
  days = dwg$days,
  pe_inputs_list = inputs_pe
)
 

# Next steps - 3.) update "inputs_pe$census_expan" object -- currenlty not using the indirect census expansion values from database due to naming issue in database (i.e., direct_census_bank should be indirect_census_boat) and ability/use of pivot_wider function to handle column header prefixes.

```

## Summary PE

### Effort estimates
```{r PE_effort_summary}

# effort by section_num

 estimates_pe$effort |>
        group_by(section_num) |> 
        summarise(
          E_sum = sum(est, na.rm=T),
          .groups = "drop"
        ) |> 
  pivot_wider(names_from = section_num, values_from = E_sum) |>
  gt(caption = paste("Estimated effort (angler hours) by fishing section from", params$est_date_start, "to", params$est_date_end))

```

```{r plot_pe_effort_estimates, fig.cap= "Estimated effort (angler-hours) grouped by time strata, section and angler type (angler_final)."}
# barplot of effort estimates by time stratum, section, and angler type
plot_est_pe_effort(estimates_pe_effort = estimates_pe$effort,
                   period_pe = params$period_pe)

```
### Catch rate (CPUE) estimates

```{r pe_cpue_period_plots, results = 'hide'}

pe_cpue_period_plots <- unique(inputs_pe$daily_cpue_catch_est$est_cg) |> 
  set_names() |> 
  map(
    ~plot_inputs_pe_cpue_period(
      days = dwg$days,
      dwg_summarized = dwg_summ,
      daily_cpue_catch_est = inputs_pe$daily_cpue_catch_est,
      est_catch_group = .x,
      period_pe = params$period_pe)
  )
      
pe_cpue_period_plots

```

Estimated catch per unit effort (fish/hour) grouped by catch group, period, section, angler type, and day-type. 

### Catch estimates

```{r PE_catch_summary}

estimates_pe$catch |> 
        group_by(est_cg, section_num) |>
        summarise(
          C_sum = sum(est),
          .groups = "drop"
        ) |> 
      pivot_longer(
        cols = -c(est_cg, section_num),
        names_to = "estimate",
        values_to = "PE"
      ) |> 
  select(est_cg, section_num, estimate, PE, everything()) |> 
  gt(groupname_col = "est_cg", caption = "Total estimates of catch during the monitoring period for each fish catch group.") |>
  fmt_number(-c(estimate, est_cg, section_num), decimals = 1) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "PE")
  ) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "PE")
  )
```


```{r plot_pe_catch_estimates, results = 'hide'}
# barplot of catch estimates by catch group, time stratum, section, and angler type

pe_catch_est_plots <- unique(estimates_pe$catch$est_cg) |> 
  set_names() |> 
  map(
    ~plot_est_pe_catch(
      estimates_pe_catch = estimates_pe$catch,
      est_catch_group = .x,
      period_pe = params$period_pe)
  )
      
pe_catch_est_plots
```

Estimated catch grouped by catch group, period, section, angler type,and day type. 

# BSS estimation

```{r prep_inputs_bss, eval=FALSE}
if(!exists(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_data_", params$fishery_name, ".rds")))){
  #either a single element list for a single catch_group
  #or a list of bss-input-lists, one for each catch_group
  inputs_bss <- unique(dwg_summ$interview$est_cg) |> 
    set_names() |> 
    map(
      ~prep_inputs_bss(
        est_catch_group = .x,
        period = params$period_bss,
        days = dwg$days,
        dwg_summarized = dwg_summ,
        #likely warrants revision? targeting n-gears-rows by n-sections-cols matrix of values
        tie_in_mat = dwg$effort |> 
          filter(tie_in_indicator == 1) |> 
          distinct(section_num, p_census_bank, p_census_boat) |> 
          pivot_longer(starts_with("p_census"), names_to = "ang", values_to = "val") |> 
          arrange(section_num) |> 
          pivot_wider(names_from = section_num, values_from = val) |> 
          select(-ang) |> 
          as.matrix(),
        priors = c(
          value_cauchyDF_sigma_eps_C = 0.5,
          value_cauchyDF_sigma_eps_E = 0.5,
          value_cauchyDF_sigma_r_E = 0.5,  
          value_cauchyDF_sigma_r_C = 0.5,  
          value_cauchyDF_sigma_mu_C = 0.5, 
          value_cauchyDF_sigma_mu_E = 0.5, 
          value_normal_sigma_omega_C_0 = 1,
          value_normal_sigma_omega_E_0 = 3,
          value_lognormal_sigma_b = 1,
          value_normal_sigma_B1 = 5,  
          value_normal_mu_mu_C = log(0.02),
          value_normal_sigma_mu_C = 1.5,  
          value_normal_mu_mu_E = log(5),
          value_normal_sigma_mu_E = 2,  
          value_betashape_phi_E_scaled = 1, 
          value_betashape_phi_C_scaled = 1 
        )
      )
    )
  saveRDS(inputs_bss,file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_data_", params$fishery_name, ".rds")))
}else(
  inputs_bss <- readRDS(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_data_", params$fishery_name, ".rds")))
)

```

```{r estimates_bss, eval=FALSE}
#should work for either single or multiple catch_group 
estimates_bss <- list()

for(ecg in names(inputs_bss)) {
  gc(verbose = TRUE)
  
  bss_fit_file <- file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name, ".rds"))
  
  if (!file.exists(bss_fit_file)) {
    ecg_fit <- fit_bss(
      bss_inputs_list = inputs_bss[[ecg]],
      n_chain = 4,  
      n_cores = 4,
      n_iter = 2000,
      n_warmup = 1000,
      n_thin = 1,
      adapt_delta = 0.8,
      max_treedepth = 10,
      init = "0"
    )
    
    saveRDS(ecg_fit, bss_fit_file)
  } else {
    ecg_fit <- readRDS(bss_fit_file)
  }
  
  ecg_keep <- list()
  
  ecg_keep$overview <- get_bss_overview(bss_fit = ecg_fit, ecg = ecg)
  
  ecg_keep$cpue_daily <- get_bss_cpue_daily(bss_fit = ecg_fit, ecg = ecg)
  
  ecg_keep$catch_daily <- get_bss_catch_daily(bss_fit = ecg_fit, ecg = ecg)
  
  ecg_keep$effort_daily <- get_bss_effort_daily(bss_fit = ecg_fit, ecg = ecg)
  
  ecg_keep$draws <- extract(ecg_fit)
  
  estimates_bss[[ecg]] <- ecg_keep
  
  rm(ecg_fit, ecg_keep); gc()
}

```

## summary BSS

```{r BSS_summary, eval= FALSE}

# effort by section_num

map_df(estimates_bss, ~.x$overview) |> 
  gt(groupname_col = "est_cg") |>
  fmt_number(-c(estimate, est_cg), decimals = 1) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "50%")
  ) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "50%")
  )

```


## plot probability density function of effort and catch 

```{r, eval=FALSE}

season_results <- map_df(estimates_bss, ~.x$draws$C_sum) |> 
  mutate(iter = row_number()) |> 
  pivot_longer(cols = -(iter), names_to = "est_cg", values_to = "C_sum")

map_df(estimates_bss, ~.x$draws$C_sum) |> 
  mutate(iter = row_number()) |> 
  pivot_longer(cols = -(iter), names_to = "est_cg", values_to = "C_sum") |> 
  ggplot(aes(x=C_sum,fill=C_sum)) +
  facet_wrap(~ est_cg, ncol=1,scales = 'free') +
  theme_bw() +
  geom_density() +
  ylab(NULL) +
  geom_vline(
    season_results |> 
      group_by(est_cg) |> 
      summarise(C_sum = quantile(C_sum, c(0.025, 0.5, 0.975)), q = c(0.025, 0.5, 0.975)), mapping=aes(xintercept=C_sum,group=est_cg),linetype="dashed") +
theme(legend.title = element_blank())
    
```



## plot daily catch BSS

```{r, eval=FALSE}

map_df(estimates_bss, ~.x$catch_daily) |> 
    ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
    geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
    geom_line(lwd = 1) +
    ylab("Median (50%) catch") +
    xlab("Date") +
    labs(color = "Angler type", fill = "Angler type") +
    scale_x_date() +
    theme_bw() +
    facet_wrap(~section_num + est_cg)

```


## plot daily effort BSS

```{r,  eval=FALSE}

estimates_bss[[1]]$effort_daily |> 
    ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
    geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
    geom_line(lwd = 1) +
    ylab("Median (50%) effort (angler hours)") +
    xlab("Date") +
    labs(color = "Angler type", fill = "Angler type") +
    scale_x_date() +
    theme_bw() +
    facet_wrap(~section_num, nrow = estimates_bss[[1]]$effort_daily$section_num |> n_distinct())


```


## plot daily CPUE BSS

```{r, eval=FALSE}

map_df(estimates_bss, ~.x$cpue_daily) |> 
    ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
    geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
    geom_line(lwd = 1) +
    ylab("Median (50%) catch per unit effort (fish/hour") +
    xlab("Date") +
    labs(color = "Angler type", fill = "Angler type") +
    scale_x_date() +
    theme_bw() +
    facet_wrap(~section_num + est_cg)

```


# PE/BSS combined summary

```{r combo_overview, eval=FALSE}
#per-est_cg summary of total effort hours and catch/encounters, showing results of both PE and BSS estimation methods

map_df(estimates_bss, ~.x$overview) |> 
  left_join(
    bind_cols(
      estimates_pe$catch |> 
        group_by(est_cg) |>
        summarise(
          C_sum = sum(est),
          .groups = "drop"
        ),
      estimates_pe$effort |> 
        summarise(
          E_sum = sum(est, na.rm=T),
          .groups = "drop"
        )
    ) |> 
      pivot_longer(
        cols = -est_cg,
        names_to = "estimate",
        values_to = "PE"
      )
    ,
    by = c("estimate", "est_cg")
  ) |> 
  select(est_cg, estimate, PE, everything()) |> 
  gt(groupname_col = "est_cg") |>
  fmt_number(-c(estimate, est_cg), decimals = 1) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "PE")
  ) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "PE")
  ) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "50%")
  ) |> 
  tab_style(
    style = cell_fill(), locations = cells_body(columns = "50%")
  )

```


# Save results
```{r write_out_results, eval = FALSE}
# bss_overview <- estimates_bss$summary_by_catchgroup
#write out a workbook with results from model runs 


## how to write out html to outputs file path??

# data fetched from dwg and summarized data used for PE and BSS (dwg_summ)
if(nchar(params$output_location_filepath) > 1) {
  writexl::write_xlsx(
  c(set_names(dwg, paste0("dwg_", names(dwg))), set_names(dwg_summ, paste0("dwg_summ", names(dwg_summ)))),
  path = file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("fetch_dwg_", params$fishery_name, ".xlsx"))
  )
}

# PE output
if(nchar(params$output_location_filepath) > 1) {
  writexl::write_xlsx(
  c(estimates_pe[rev(names(estimates_pe))]),
  path = file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("pe_output_", params$fishery_name, ".xlsx"))
  )
}

# overview of BSS output
# if(nchar(params$output_location_filepath) > 1) {
#   writexl::write_xlsx(bss_overview,
#   path = file.path(where("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_overview_", params$fishery_name, ".xlsx"))
#   )
# }
```


## Posterior Predictive Check for BSS
```{r PPC, eval = FALSE}
stan_fit<-readRDS(file.path(here::here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name, ".rds")))


sections<-dwg$effort |> 
  filter(location_type == "Section") |> 
  distinct(water_body, section_num, location) |> 
  arrange(section_num) |>
  dplyr::select(water_body,section=section_num,location)

# write.csv(summary(stan_fit)$summary,file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_summary_", params$fishery_name, ".csv")))

# stan_fit<-readRDS(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name, "_ZINB.rds")))
# 
# write.csv(summary(stan_fit)$summary,file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_summary_", params$fishery_name, "_ZINB.csv")))

V_I_pvalue<-extract(stan_fit)$V_I_rep%>%
  reshape2::melt()%>%
  dplyr::rename(V_n=Var2)%>%
  left_join(
    tibble(
      V_I=inputs_bss[[ecg]]$V_I,
      V_n = 1:inputs_bss[[ecg]]$V_n, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(V_I),1,0),
    sd_gt=ifelse(sd(value)>sd(V_I),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )


T_I_pvalue<-extract(stan_fit)$T_I_rep%>%
  reshape2::melt()%>%
  dplyr::rename(T_n=Var2)%>%
  left_join(
    tibble(
      T_I=inputs_bss[[ecg]]$T_I,
      T_n = 1:inputs_bss[[ecg]]$T_n, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(T_I),1,0),
    sd_gt=ifelse(sd(value)>sd(T_I),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )



E_s_pvalue<-extract(stan_fit)$E_s_rep%>%
  reshape2::melt()%>%
  dplyr::rename(E_n=Var2)%>%
  left_join(
    tibble(
      E_s=inputs_bss[[ecg]]$E_s,
      E_n = 1:inputs_bss[[ecg]]$E_n, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(E_s),1,0),
    sd_gt=ifelse(sd(value)>sd(E_s),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )


c_pvalue<-extract(stan_fit)$c_rep%>%
  reshape2::melt()%>%
  dplyr::rename(IntC=Var2)%>%
  left_join(
    tibble(
      c=inputs_bss[[ecg]]$c,
      IntC = 1:inputs_bss[[ecg]]$IntC, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(c),1,0),
    sd_gt=ifelse(sd(value)>sd(c),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )


V_A_pvalue<-extract(stan_fit)$V_A_rep%>%
  reshape2::melt()%>%
  dplyr::rename(IntA=Var2)%>%
  left_join(
    tibble(
      V_A=inputs_bss[[ecg]]$V_A,
      IntA = 1:inputs_bss[[ecg]]$IntA, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(V_A),1,0),
    sd_gt=ifelse(sd(value)>sd(V_A),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )


T_A_pvalue<-extract(stan_fit)$T_A_rep%>%
  reshape2::melt()%>%
  dplyr::rename(IntA=Var2)%>%
  left_join(
    tibble(
      T_A=inputs_bss[[ecg]]$T_A,
      IntA = 1:inputs_bss[[ecg]]$IntA, 
    )
  )%>%
  group_by(iterations)%>%
  summarise(
    mean_gt=ifelse(mean(value)>mean(T_A),1,0),
    sd_gt=ifelse(sd(value)>sd(T_A),1,0)
  )%>%
  ungroup()%>%
  summarise(
    mean_gt=sum(mean_gt)/n(),
    sd_gt=sum(sd_gt)/n()
  )
```

# Posterior Predictive Checks and Interval Coverage
```{r}

# Perform posterior predictive checks
V_I_PPC<-as.data.frame(apply(extract(stan_fit)$V_I_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "V_I",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = V_I)%>%
  bind_cols(tibble(V_I=inputs_bss[[ecg]]$V_I,
                   section=inputs_bss[[ecg]]$section_V,
                   day = inputs_bss[[ecg]]$day_V,
                   countnum = inputs_bss[[ecg]]$countnum_V
                   )
  )%>%
  left_join(sections)%>%
  mutate(section=water_body)%>%
  mutate(section = as.factor(section),
         day = as.factor(day),
         countnum = as.factor(countnum),
         fit = factor(ifelse(V_I>=`2.5%` & V_I<=`97.5%`,"fit","no fit"), levels = c("fit", "no fit"))
         )

p_fit<-V_I_PPC %>%
  group_by(section) %>%
  summarise(
    fit_count = sum(fit == "fit"),
    no_fit_count = sum(fit == "no fit"),
    total_count = fit_count + no_fit_count,
    p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
  ) %>%
  ungroup()%>%
  add_row(section = "Total",
          fit_count = sum(.$fit_count),
          no_fit_count = sum(.$no_fit_count),
          total_count = sum(.$total_count),
          p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count)),
  ) %>%
  mutate(Parameter = "V_I_PPC")



V_I_PPC_plt<-ggplot(V_I_PPC, aes(x = V_I, y = V_I, color=fit)) +
  facet_grid(cols=vars(section)) +
  geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0,position = position_jitter(width=0.5,height=0)) +
  labs(x = "Observed Vehicle Counts", y = "95% PPI") +
  geom_line(color="black") +
  ylim(0, max(V_I_PPC$`97.5%`)) +
  xlim(0, max(V_I_PPC$`97.5%`)) + 
  theme_bw()+
  scale_colour_manual(values=c("#F8766D","#00BFC4"), 
                      labels=c("fit", "no fit"), 
                      drop=FALSE)


ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "V_I_PPC.png"),
       plot = V_I_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )


T_I_PPC<-as.data.frame(apply(extract(stan_fit)$T_I_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "T_I",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = T_I)%>%
  bind_cols(tibble(T_I=inputs_bss[[ecg]]$T_I,
                   section=inputs_bss[[ecg]]$section_T,
                   day = inputs_bss[[ecg]]$day_T,
                   countnum = inputs_bss[[ecg]]$countnum_T
                   )
  )%>%
  left_join(sections)%>%
  mutate(section=water_body)%>%
  mutate(section = as.factor(section),
         day = as.factor(day),
         countnum = as.factor(countnum),
         fit = factor(ifelse(T_I>=`2.5%` & T_I<=`97.5%`,"fit","no fit"),levels = c("fit", "no fit"))
         )

p_fit<-p_fit%>%
  bind_rows(T_I_PPC %>%
    group_by(section) %>%
    summarise(
      fit_count = sum(fit == "fit"),
      no_fit_count = sum(fit == "no fit"),
      total_count = fit_count + no_fit_count,
      p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
    ) %>%
    ungroup()%>%
    add_row(section = "Total",
            fit_count = sum(.$fit_count),
            no_fit_count = sum(.$no_fit_count),
            total_count = sum(.$total_count),
            p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count))
    ) %>%
    mutate(Parameter = "T_I_PPC")
  )



T_I_PPC_plt<-ggplot(T_I_PPC, aes(x = T_I, y = T_I, color=fit)) +
  facet_grid(cols=vars(section)) +
  geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0,position = position_jitter(width=0.5,height=0))  +
  labs(x = "Observed Trailer Counts", y = "95% PPI") +
  geom_line(color="black") +
  ylim(0, max(T_I_PPC$`97.5%`)) +
  xlim(0, max(T_I_PPC$`97.5%`)) +
  theme_bw()+
  scale_colour_manual(values=c("#F8766D","#00BFC4"), 
                      labels=c("fit", "no fit"), 
                      drop=FALSE)

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "T_I_PPC.png"),
       plot = T_I_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

E_s_PPC<-as.data.frame(apply(extract(stan_fit)$E_s_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "E_s",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = E_s)%>%
  bind_cols(tibble(E_s=inputs_bss[[ecg]]$E_s,
                   section=inputs_bss[[ecg]]$section_E,
                   day = inputs_bss[[ecg]]$day_E,
                   gear = inputs_bss[[ecg]]$gear_E,
                   countnum = inputs_bss[[ecg]]$countnum_E
                   )
  )%>%
  left_join(sections)%>%
  mutate(section=water_body,
         gear = case_when(
           gear == 1 ~ "Bank Anglers",
           gear == 2 ~ "Boat Anglers" 
      )
    )%>%
  mutate(section = as.factor(section),
         day = as.factor(day),
         gear= as.factor(gear),
         countnum = as.factor(countnum),
         fit = factor(ifelse(E_s>=`2.5%` & E_s<=`97.5%`,"fit","no fit"),levels=c("fit","no fit"))
         )

p_fit<-p_fit%>%
  bind_rows(E_s_PPC %>%
    group_by(section, gear) %>%
    summarise(
      fit_count = sum(fit == "fit"),
      no_fit_count = sum(fit == "no fit"),
      total_count = fit_count + no_fit_count,
      p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
    ) %>%
    ungroup()%>%
    add_row(section = "Total", gear ="Total",
            fit_count = sum(.$fit_count),
            no_fit_count = sum(.$no_fit_count),
            total_count = sum(.$total_count),
            p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count))
    ) %>%
    mutate(Parameter = "E_s_PPC")
  )



E_s_PPC_plt<-ggplot(E_s_PPC, aes(x = E_s, y = E_s, color=fit, groups=gear)) +
  facet_grid(cols=vars(section),rows=vars(gear)) +
  geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0, position = position_jitter(width=0.5,height=0)) +
  labs(x = "Observed Angler Counts", y = "95% PPI") +
  geom_line(color="black") +
  ylim(0, max(E_s_PPC$`97.5%`)) +
  xlim(0, max(E_s_PPC$`97.5%`))+ 
  theme_bw()+
  scale_colour_manual(values=c("#F8766D","#00BFC4"), 
                      labels=c("fit", "no fit"), 
                      drop=FALSE)

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "E_s_PPC.png"),
       plot = E_s_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )


c_PPC<-as.data.frame(apply(extract(stan_fit)$c_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "c",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = c)%>%
  bind_cols(tibble(c=inputs_bss[[ecg]]$c,
                   section=inputs_bss[[ecg]]$section_IntC,
                   day = inputs_bss[[ecg]]$day_IntC,
                   gear = inputs_bss[[ecg]]$gear_IntC,
                   )
  )%>%
  left_join(sections)%>%
  mutate(section=water_body,
         gear = case_when(
           gear == 1 ~ "Bank Anglers",
           gear == 2 ~ "Boat Anglers" 
      )
    )%>%
  mutate(section = as.factor(section),
         day = as.factor(day),
         gear= as.factor(gear),
         fit = factor(ifelse(c>=`2.5%` & c<=`97.5%`,"fit","no fit"))
         )

p_fit<-p_fit%>%
  bind_rows(c_PPC%>%
    group_by(section, gear) %>%
    summarise(
      fit_count = sum(fit == "fit"),
      no_fit_count = sum(fit == "no fit"),
      total_count = fit_count + no_fit_count,
      p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
    ) %>%
    ungroup()%>%
    add_row(section = "Total", gear ="Total",
            fit_count = sum(.$fit_count),
            no_fit_count = sum(.$no_fit_count),
            total_count = sum(.$total_count),
            p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count))
    )%>%
    mutate(Parameter = "c_PPC")
  )



c_PPC_plt<-ggplot(c_PPC, aes(x = c+1, y = c+1, color=fit, groups=interaction(gear,section))) +
  facet_grid(cols=vars(section),rows=vars(gear)) +
  geom_errorbar(aes(ymin = `2.5%` + 1, ymax = `97.5%` + 1), width = 0,position = position_jitter(width = 0.2, height=0)) +
  labs(x = "Observed Catch", y = "95% PPI") +
  geom_line(color="black") +
  #scale_x_log10()+
  #scale_y_log10()+
  #annotation_logticks()+ 
  scale_y_continuous(breaks = seq(1, 10, by = 1))+
  scale_x_continuous(breaks = seq(1, 10, by = 1))+
  theme_bw()
  #ylim(1, max(c_PPC$`97.5%`)) +
  #xlim(1, max(c_PPC$`97.5%`))
ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "c_PPC.png"),
       plot = c_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )


V_A_PPC<-as.data.frame(apply(extract(stan_fit)$V_A_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "V_A",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = V_A)%>%
  bind_cols(tibble(V_A=inputs_bss[[ecg]]$V_A,
                   gear = inputs_bss[[ecg]]$gear_IntA
                   )
  )%>%
  mutate(gear = case_when(
    gear == 1 ~ "Bank Anglers",
    gear == 2 ~ "Boat Anglers"
    )
  )%>%  
  mutate(gear= as.factor(gear),
         fit = factor(ifelse(V_A>=`2.5%` & V_A<=`97.5%`,"fit","no fit"),levels=c("fit", "no fit"))
         )

p_fit<-p_fit%>%
  bind_rows(V_A_PPC %>%
    group_by(gear) %>%
    summarise(
      fit_count = sum(fit == "fit"),
      no_fit_count = sum(fit == "no fit"),
      total_count = fit_count + no_fit_count,
      p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
    ) %>%
    ungroup()%>%
    add_row(gear ="Total",
            fit_count = sum(.$fit_count),
            no_fit_count = sum(.$no_fit_count),
            total_count = sum(.$total_count),
            p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count))
    )%>%
    mutate(Parameter = "V_A_PPC")
  )


V_A_PPC_plt<-ggplot(V_A_PPC, aes(x = V_A, y = V_A,color=fit)) +
  facet_grid(cols=vars(gear)) +
  geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0,position = position_jitter(width = 0.2, height=0)) +
  labs(x = "Observed Angler Group Vehicles", y = "95% PPI") +
  geom_line(color="black") +
  ylim(0, max(V_A_PPC$`97.5%`)) +
  xlim(0, max(V_A_PPC$`97.5%`))+ 
  theme_bw()+
  scale_colour_manual(values=c("#F8766D","#00BFC4"), 
                      labels=c("fit", "no fit"), 
                      drop=FALSE)

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "V_A_PPC.png"),
       plot = V_A_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )


T_A_PPC<-as.data.frame(apply(extract(stan_fit)$T_A_rep,2, function(x) quantile(x, c(0.025,0.975))))%>%
  rownames_to_column(var="Quantile")%>%
  as_tibble()%>%
  pivot_longer(names_to = "names",values_to = "T_A",cols = c(-Quantile))%>%
  pivot_wider(names_from = Quantile,values_from = T_A)%>%
  bind_cols(tibble(T_A=inputs_bss[[ecg]]$T_A,
                   gear = inputs_bss[[ecg]]$gear_IntA
                   )
  )%>%
  mutate(gear = case_when(
    gear == 1 ~ "Bank Anglers",
    gear == 2 ~ "Boat Anglers"
    )
  )%>%    
  mutate(gear= as.factor(gear),
         fit = factor(ifelse(T_A>=`2.5%` & T_A<=`97.5%`,"fit","no fit"),levels=c("fit","no fit"))
         )


p_fit<-p_fit%>%
  bind_rows(T_A_PPC %>%
    group_by(gear) %>%
    summarise(
      fit_count = sum(fit == "fit"),
      no_fit_count = sum(fit == "no fit"),
      total_count = fit_count + no_fit_count,
      p_fit = ifelse(no_fit_count == 0, 1, fit_count / total_count)
    )%>%
    ungroup()%>%
    add_row(gear = "Total", 
            fit_count = sum(.$fit_count),
            no_fit_count = sum(.$no_fit_count),
            total_count = sum(.$total_count),
            p_fit = ifelse(sum(.$no_fit_count) == 0, 1, sum(.$fit_count) / sum(.$total_count))
    ) %>%
    mutate(Parameter = "T_A_PPC")
  )


T_A_PPC_plt<-ggplot(T_A_PPC, aes(x = T_A, y = T_A,color=fit)) +
  facet_grid(cols=vars(gear)) +
  geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0,position = position_jitter(width = 0.2, height=0)) +
  labs(x = "Observed Angler Group Trailers", y = "95% PPI") +
  geom_line(color="black") +
  ylim(0, max(T_A_PPC$`97.5%`)) +
  xlim(0, max(T_A_PPC$`97.5%`))+
  theme_bw()+
  scale_colour_manual(values=c("#F8766D","#00BFC4"), 
                      labels=c("fit", "no fit"), 
                      drop=FALSE)

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "T_A_PPC.png"),
       plot = T_A_PPC_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

p_fit%>%
  dplyr::select(Parameter,
                Section = section,
                Gear = gear,
                `Fit count` = fit_count,
                `No fit count` = no_fit_count,
                `Total n` = total_count,
                `2.5% Q > Pr.(obs) < 97.5% Q` = p_fit
                )%>%
  #kableExtra::kbl()%>%
  #kableExtra::kable_classic(font="Times New Roman")%>%
  write.csv(file.path(here("fishery_analyses", params$project_name, params$fishery_name), "p_fit.csv"),row.names=F)


p<-gridExtra::grid.arrange(
  V_I_PPC_plt,
  T_I_PPC_plt,
  nrow=2
)

p2<-gridExtra::grid.arrange(
  V_A_PPC_plt,
  T_A_PPC_plt,
  nrow=2
)

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "VI_TI_PPC.png"),
       plot = p,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name), "VA_TA_PPC.png"),
       plot = p2,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

```


## Pre-season Fishery Planning
This section displays the pre-season Skagit wild winter steelhead run-size forecast, the exploitation rate matrix prescribed by the Resource Management Plan, and uses the two to calculate the allowable harvest. It then compares the planned harvest (sport fishery catch * assumed catch and release mortality rate) with the allowable harvest to estimate the percent of the allowable harvest the sport fishery will use as well as the probability that the sport fishery will exceed various percentages of the allowable impacts.

First, the allowable harvest rates in the RMP are:
```{r message = FALSE, warning = FALSE,results = "asis",include=TRUE, echo=FALSE}
hcr<-read_csv(file.path(here("fishery_analyses", params$project_name, params$fishery_name),"hcr.csv"))
hcr%>%mutate(MaxRunsize=format(MaxRunsize, scientific = FALSE))%>%
  rename(`Exploitation Rate` = ER, `Minimum Run Size` = MinRunsize,`Maximum Run Size` = MaxRunsize)%>%
  kableExtra::kbl(caption = "Table 1. Allowable Harvest Rates, Skagit RMP ",digits =3)%>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria")
```

The run size forecast is below, and is reprinted from the co-manager agreed-to [**pre-season forecast**](https:#github.com/tbuehrens/Skagit-River-Steelhead-Forecast/blob/master/analysis/App_2_Model_fitting_forecast_2020_2021_step_head_fcst.pdf). A published scientific paper describing the methods may be found here: [**(preseason forecast publication)**](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/1365-2664.13789).

For more details on how this forecast was developed, see this [**GitHub repository**](https://github.com/casruff/Skagit-River-Steelhead-Forecast), which is collaboratively maintained by tribal Co-Managers & WDFW.

```{r include=TRUE, fig.align="center", fig.cap=c("Figure 1. Skagit Steelhead Run-size Forecast. The forecast is shown as a 'bell curve' (though not symmetric), where the height of the curve is proportional to the probability that the true value (catch or effort) is equal to a particular value on the x-axis. The 'best' value is the 50th percentile, shown as a dashed line."),echo=FALSE}
runsize<-read_csv(file.path(here("fishery_analyses", params$project_name, params$fishery_name),"ensemble_forecast_posterior.csv"))
runsize_plt<-ggplot(data=runsize,aes(x=ensemble_forecast_posterior))+
  geom_density(aes(y=..density.. / max(..density..)),fill="forest green")+
  #geom_vline(data=runsize,mapping=aes(xintercept=median(ensemble_forecast_posterior)),linetype="dashed",linewidth=1.5)+
   geom_vline(data=hcr%>%filter(MinRunsize!=0),mapping=aes(xintercept=MinRunsize),linetype="dashed")+
  xlab("Forecasted Run-Size")+
  ylab("Relative Probability")+
  theme_bw()+
  xlim(0,12000)
print(runsize_plt)


runsize%>%
  summarise(`Run Size` = round(quantile(ensemble_forecast_posterior, c(0.025, 0.25, 0.5,0.75, 0.975))), q = c(0.025,0.25, 0.5,0.75, 0.975)*100)%>%
  dplyr::rename(Percentile=q)%>%
  kableExtra::kbl(caption = "Table 2. Runsize Forecast. The 'best' estimate is the median or 50th percentile. The table shows the forecast percentiles, which represent the probability that the true run-size will fall below a particular value. For example, there is a 50% probability the true run size will be below the 50th percentile of the forecast.",digits =3,format = "html", table.attr = "style='width:40%;'")%>%
  kableExtra::kable_classic(html_font = "Cambria")
```

### Fishery Impacts Relative to Resource Management Plan Limits: Preseason Plan
Below you will find a comparison of the the planned sport fishery catch, assuming 10 percent catch and release mortality, with the allowable harvest based on the run size forecast and the RMP mortality limits.

The allowable harvest, according to the RMP, is the number of fish that may be killed by the combined sport and tribal fisheries. However, as seen above, this number depends on the run-size, which fishery managers will not know until after the fishing season when they estimate escapement. However, based on the pre-season forecast run size, we can estimate what the true allowable harvest will be by combining the forecast run size, including its uncertainty, with the harvest rate matrix prescribed by the RMP. We can then plot the probability that the true allowable harvest will exceed a range of values. The true allowable harvest will be known with more certainty after the season when the actual run-size is known and the appropriate harvest rate from the matrix can be multiplied by the actual run size.

For example, in 2021 there is a greater than 90 percent chance that the true allowable harvest based on the true run size and the harvest matrix, will exceed 100 fish. There is a 50% chance that the allowable harvest will exceed 430 fish (10 percent of the best estimate of the run-size from the forecast), and a very small chance the allowable harvest will be greater than 2,000 fish:
```{r include=TRUE, fig.align="center", fig.cap=c("Figure 2. Probability that the allowable harvest exceeds a particular number of fish based on the RMP. Note the log10 scale on the x-axis."),echo=FALSE}
ER_func<-function(hcr,runsize){
  ER<-c(NULL)
  indexes<-c(NULL)
  for(i in 1:nrow(hcr)){
    runsize=round(runsize)
    min<-hcr$MinRunsize[i]
    max<-hcr$MaxRunsize[i]
    ind<-which(min <= runsize & runsize <= max)
    indexes<-c(indexes,ind)
    ER<-c(ER,rep(hcr$ER[i],length(ind)))
    ERdat<-data.frame(indexes,ER)
  }
 return(ERdat)
}
ER<-ER_func(hcr=hcr,runsize=runsize)
AH<-data.frame(ER$ER,runsize)
AH$AH<-AH$ER.ER*AH$ensemble_forecast_posterior
AH$Exceedence<-rev(sort(percent_rank(AH$AH)))
#hist(AH$AH,breaks=seq(0,max(AH$AH)*1.1,100))

breaks <- 10^(-10:10)
minor_breaks <- rep(1:9, 21)*(10^rep(-10:10, each=9))

allowable_harvest_plt<-ggplot(data=AH,aes(x=AH,y=Exceedence))+
  geom_line(size=1.25)+
  theme_bw()+
  scale_x_log10(breaks = breaks, minor_breaks = minor_breaks)+
  annotation_logticks(base = 10,sides = "b")+
  ylab("Probability of Exceedance")+
  xlab("Allowable (State + Tribal) Co-manager Harvest (fish)")

print(allowable_harvest_plt)
```

Given the uncertainty in what the allowable harvest will turn out to be, managers must balance the risk of exceeding the allowable harvest with the cost of erring so heavily on the side of conservation (to ensure the allowable harvest is not exceeded) that no fishery is allowed at all. To assist with this task, managers can plan a fishery to harvest a particular number of fish (which itself may be estimated with uncertainty) and then calculate the probability that the allowable harvest will turn out to have been exceeded if the planned fishery is implemented.

For example, in 2021, a four-day a week fishery was planned with a projected total harvest of 76 fish (760 wild fish handled * assumed 10 percent catch and release mortality rate). If the actual catch matches the projection exactly, this would translate to 18 percent of the allowable (sport and tribal) harvest under the RMP if the true allowable harvest is 430 (which is the best estimate from the preseason forecast, and corresponds to the 50% exceedance probability).

```{r include=TRUE, fig.align="center", fig.cap=c("Figure 3. Probability that the pre-season planned sport fishery harvest exceeds the allowable harvest (expressed as percentages) under the RMP. Vertical lines denote 50 percent of the allowable harvest, which is shared between the state and tribes, and 100 percent of the allowable harvest. The best estimate of the percent of the allowable harvest that will be used by the sport fishery is located on the graph where the probability of exceedance is 50 percent."),echo=FALSE}
preseason_planned_mortalities<-76
H_plan<-rlnorm(1000,log(preseason_planned_mortalities),0.1)
PAH_plan<-(sample(H_plan,10000,replace = T)/sample(AH$AH,10000,replace = T))*100
PAHdat_plan<-data.frame(PAH_plan,percent_rank(-PAH_plan))%>%rename(Exceedence="percent_rank..PAH_plan.")
ggplot(data=PAHdat_plan,aes(x=PAH_plan,y=Exceedence))+
  geom_line(size=1.25)+
  theme_bw()+
  ylab("Probability of Exceedance")+
  xlab("% of Allowable (Sport + Tribal) Co-Manager Harvest")+
  geom_vline(xintercept=50)+
  geom_vline(xintercept=100,col="red")
```

```{r include=TRUE, fig.align="center", fig.cap=c("Figure 4. Pre-season Planned Probability that the sport fishery harvest exceeds 50 and 100 percent of the allowable harvest under the RMP, as well as the best estimate of the percentage of allowable impacts the sport fishery will use"),echo=FALSE}

probs_plan<-tibble(
  parameter= c("best estimate of sport \nfishery impacts as \n % of total (sport + tribal) \n allowable",
               "probability sport fishery \n impacts > 50% of total \n (sport + tribal) allowable",
               "probability sport fishery \n impacts > 100% of total \n (sport + tribal) allowable"),
  probability=c(PAHdat_plan$PAH[which(abs(PAHdat_plan$Exceedence - 0.5)==min(abs(PAHdat_plan$Exceedence - 0.5)))],
                PAHdat_plan$Exceedence[which(abs(PAHdat_plan$PAH - 50)==min(abs(PAHdat_plan$PAH - 50)))]*100,
                PAHdat_plan$Exceedence[which(abs(PAHdat_plan$PAH - 100)==min(abs(PAHdat_plan$PAH - 100)))]*100
                )
  )


plot <- ggplot(probs_plan, aes(y = probability, x = parameter)) +
  geom_bar(stat = "identity", fill = "forestgreen") +
  ylim(0, 100) +
  coord_flip() +  # Horizontal orientation
  labs(
    title = "Pre-season Estimate",
    x = "Probability",
    y = NULL  # Remove y-axis label
  ) +
  theme_bw()+
  geom_hline(yintercept=50,color="red",linetype="dashed")

print(plot)
```

## In-season Fishery Results

WDFW fishery managers use data from creel surveys to estimate the season total and daily catch and effort, and the daily catch per unit effort (CPUE). Results presented below include data collected through: **`r params$est_date_end`**

### Disclaimer
Contents on this page should be treated as preliminary and are subject to change. While every effort has been made to ensure the accuracy of data and modeling here, some numbers may change. Particularly in-season catch and effort estimates may change as additional data becomes available, and as data errors are corrected.

### Season Total Effort and Catch

This table and the figures below it show estimates of the season total catch and effort. Estimates are shown as 'bell curves' (though not symmetric), where the height of the curve is proportional to the probability that the true value (catch or effort) is equal to a particular value on the x-axis. The "best" estimate is the 50th percentile (median) in the table, and is denoted by the middle dashed line in the graphs:
```{r run_resid_analysis, message = FALSE, warning = FALSE,results = "asis",include=TRUE, echo=FALSE}
total_effort_catch_tbl<-estimates_bss %>%
  map_df(~ .x$overview) 



total_effort_catch_tbl%>%
  kableExtra::kbl(caption = "Table 3. Total Catch (fish) and Effort (hours). The 'best' estimate is the median or 50th percentile. The table shows the percentiles of estimated catch and effort, which represent the probability that the true catch or effort is below a particular value. For example, there is a 50% probability the true catch is below the 50th percentile of the estimated catch in this table.", digits = 1) %>%
  kableExtra::kable_classic(full_width = FALSE, html_font = "Cambria")



res<-rstan::extract(stan_fit)

#Seasonal median CPUE gear section
median_CPUE_gear_section<-apply(exp(res$mu_C),2:3,function (x) c(mean=mean(x),sd=sd(x),quantile(x,c(0.025,0.25,0.5,0.75,0.975))))%>%
  reshape2::melt()%>%
  rename(Q=Var1,gear=Var2,section=Var3,CPUE=value)%>%
  as_tibble()%>%
  pivot_wider(names_from = Q,values_from = CPUE)%>%
  left_join(sections)%>%
  select(-section,-location)%>%
  rename(section=water_body)%>%
  mutate(gear=ifelse(gear==1,"Bank Anglers","Boat Anglers"),
         Parameter ="seasonal median CPUE"
         )%>%
  select(Parameter,section,gear,mean,sd,`2.5%`,`25%`,`50%`,`75%`,`97.5%`)


#Seasonal total catch gear section
catch_gear_section<-apply(apply(res$C,c(1,2,4),sum), 2:3,function (x) c(mean=mean(x),sd=sd(x),quantile(x,c(0.025,0.25,0.5,0.75,0.975))))%>%
  reshape2::melt()%>%
  rename(Q=Var1,section=Var2,gear=Var3,catch=value)%>%
  as_tibble()%>%
  pivot_wider(names_from = Q,values_from = catch)%>%
  left_join(sections)%>%
  select(-section,-location)%>%
  rename(section=water_body)%>%
  mutate(gear=ifelse(gear==1,"Bank Anglers","Boat Anglers"),
         Parameter ="season total catch"
         )%>%
  select(Parameter,section,gear,mean,sd,`2.5%`,`25%`,`50%`,`75%`,`97.5%`)


#Seasonal total catch gear section
effort_gear_section<-apply(apply(res$E,c(1,2,4),sum), 2:3,function (x) c(mean=mean(x),sd=sd(x),quantile(x,c(0.025,0.25,0.5,0.75,0.975))))%>%
  reshape2::melt()%>%
  rename(Q=Var1,section=Var2,gear=Var3,effort=value)%>%
  as_tibble()%>%
  pivot_wider(names_from = Q,values_from = effort)%>%
  left_join(sections)%>%
  select(-section,-location)%>%
  rename(section=water_body)%>%
  mutate(gear=ifelse(gear==1,"Bank Anglers","Boat Anglers"),
         Parameter = "season total effort"
         )%>%
  select(Parameter,section,gear,mean,sd,`2.5%`,`25%`,`50%`,`75%`,`97.5%`)


season_results<-data.frame(res$C_sum,res$E_sum)%>%
  mutate(iter=row_number())%>%
  as_tibble()%>%
  rename(`Season Total Catch`=res.C_sum,`Season Total Effort`=res.E_sum)%>%
  mutate(`Seasonal Mean CPUE` = `Season Total Catch`/`Season Total Effort`)%>%
  pivot_longer(names_to = "Parameter",values_to="value",cols=c(`Season Total Catch`,`Season Total Effort`,`Seasonal Mean CPUE`))%>%
  group_by(Parameter)%>%
  summarise(mean=mean(value), 
            sd=sd(value),
            v=quantile(value,c(0.025,0.25,0.5,0.75,0.975)),
            q=c("2.5%","25%","50%","75%","97.5%")
            )%>%
  pivot_wider(names_from = q,values_from = v)%>%
  mutate(gear="Total",section="Total")%>%
  bind_rows(catch_gear_section)%>%
  bind_rows(effort_gear_section)%>%
  bind_rows(median_CPUE_gear_section)%>%
  select(Parameter,section,gear,mean,sd,`2.5%`,`25%`,`50%`,`75%`,`97.5%`)%>%
  write.csv(file.path(here("fishery_analyses", params$project_name, params$fishery_name),"total_effort_catch_tbl.csv"),row.names = F)


```


```{r, include=TRUE, fig.align="center", fig.cap=c("Figure 5. Season total catch (fish) and effort (angler hours). The middle dashed line shows the posterior median or 'best' estimate. Outer dashed lines show 95 percent credible intervals."),echo=FALSE,warning = FALSE}
total_catch_plt <- ggplot(season_results %>% 
                             filter(Parameter == "Season Total Catch")
                           , aes(x = value, fill = Parameter)
                           )+
  theme_bw() +
  geom_density(aes(y=..density.. / max(..density..)))+
  ylab("Relative \nProbability") +
  xlab("Fish") +
  geom_vline(data = season_results %>%
               filter(Parameter == "Season Total Catch")%>%
               summarise(value = quantile(value, c(0.025, 0.5, 0.975))),
             aes(xintercept = value),
             linetype = "dashed") +
  theme(legend.title = element_blank())

total_effort_plt <- ggplot(season_results %>% 
                             filter(Parameter == "Season Total Effort")
                           , aes(x = value, fill = Parameter)
                           )+
  theme_bw() +
  geom_density(aes(y=..density.. / max(..density..)))+
  ylab("Relative \nProbability") +
  xlab("Angler Hours") +
  geom_vline(data = season_results %>%
               filter(Parameter == "Season Total Effort")%>%
               summarise(value = quantile(value, c(0.025, 0.5, 0.975))),
             aes(xintercept = value),
             linetype = "dashed") +
  theme(legend.title = element_blank())

total_CPUE_plt <- ggplot(season_results %>% 
                             filter(Parameter == "Seasonal CPUE")
                           , aes(x = value, fill = Parameter)
                           )+
  theme_bw() +
  geom_density(aes(y=..density.. / max(..density..)))+
  ylab("Relative \nProbability")+
  xlab("Fish/Hour") +
  geom_vline(data = season_results %>%
               filter(Parameter == "Seasonal CPUE")%>%
               summarise(value = quantile(value, c(0.025, 0.5, 0.975))),
             aes(xintercept = value),
             linetype = "dashed") +
  theme(legend.title = element_blank())

# Print the plots
total_plt<-gridExtra::grid.arrange(
  total_catch_plt + guides(fill=FALSE),
  total_effort_plt + guides(fill=FALSE),
  total_CPUE_plt + guides(fill=FALSE),
  nrow=3
)

```

### Daily Catch, Effort, and Catch Per Unit Effort
Below, you will find an estimate of the daily catch (fish), effort (hours), and catch per unit effort (fish/hr). The lines are the "best" estimates and the shading shows the 95 percent credible intervals (which are obtained from the statistical model used to estimate catch).
```{r, include=TRUE, fig.align="center", fig.cap=c("Figure 6. Daily catch. Lines are posterior medians or 'best' estimates, while shading shows 95% credible intervals."),echo=FALSE,warning = FALSE}
daily_catch_plt<-map_df(estimates_bss, ~.x$catch_daily) |>
  left_join(sections|>dplyr::rename(section_num=section))|>
  ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
  geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
  geom_line(lwd = 1) +
  ylab("Catch (fish)") +
  xlab("Date") +
  labs(color = "Angler type", fill = "Angler type") +
  scale_x_date() +
  theme_bw() +
  facet_wrap(~water_body)+
  scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) 

print(daily_catch_plt)
```

```{r, include=TRUE, fig.align="center", fig.cap=c("Figure 7. Daily effort. Lines are posterior medians or 'best' estimates, while shading shows 95% credible intervals."), echo=FALSE,warning=F}
daily_effort_plt<-estimates_bss[[1]]$effort_daily |>
  left_join(sections|>dplyr::rename(section_num=section))|>
  ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
  geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
  geom_line(lwd = 1) +
  ylab("Effort (angler hours)") +
  xlab("Date") +
  labs(color = "Angler type", fill = "Angler type") +
  scale_x_date() +
  theme_bw() +
  facet_wrap(~water_body)

print(daily_effort_plt)

```

```{r, include=TRUE, fig.align="center", fig.cap=c("Figure 8. Daily CPUE. Lines are posterior medians or 'best' estimates, while shading shows 95% credible intervals."),echo=FALSE,warning=F}
daily_CPUE_plt<-map_df(estimates_bss, ~.x$cpue_daily) |> 
    left_join(sections|>dplyr::rename(section_num=section))|>
    ggplot(aes(x = event_date, y = `50%`, fill = angler_final, color = angler_final)) +
    geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), alpha = 0.2, color = "transparent") +
    geom_line(lwd = 1) +
    ylab("CPUE (fish/hour)") +
    xlab("Date") +
    labs(color = "Angler type", fill = "Angler type") +
    scale_x_date() +
    #scale_y_log10()+
    #annotation_logticks(sides="l")+
    theme_bw() +
    facet_wrap(~water_body)

print(daily_CPUE_plt)
```


### In-season Impact Monitoring: Fishery Impacts Relative to Resource Management Plan Limits
Here, we compare the actual in-season estimated sport fishery catch, assuming 10% C&R mortality, with the allowable harvest estimated from the forecasted run size and the RMP mortality limits, to estimate the probability that the allowable harvest has been exceeded by the actual fishery (as opposed to the pre-season plan that we looked at previously). Early in the season when little catch has occurred, the probability that the allowable harvest has been exceeded is low, but increases as the season goes on. This analyis enables an in-season quantification of risk by managers, which may be helpful in decision-making:
```{r include=TRUE, fig.align="center", fig.cap=c("Figure 9. Probability that the actual in-season estimated sport fishery harvest exceeds the allowable harvest (expressed as percentages) under the RMP. Vertical lines denote 50 percent of the allowable harvest, which is shared between the state and tribes, and 100 percent of the allowable harvest. The best in-season estimate of the percent of the allowable harvest that has been used by the sport fishery is located on the graph where the probability of exceedance is 50 percent."),echo=FALSE,warning=F}
H<-res$C_sum*0.1
PAH<-(sample(H,10000,replace = T)/sample(AH$AH,10000,replace = T))*100
PAHdat<-data.frame(PAH,percent_rank(-PAH))%>%
  rename(Exceedence="percent_rank..PAH.")

catch_exceedence_plt<-ggplot(data=PAHdat,aes(x=PAH,y=Exceedence))+
  geom_line(size=1.25)+
  theme_bw()+
  ylab("Probability of Exceedance")+
  xlab("% of Allowable (Sport + Tribal) Co-Manager Harvest")+
  xlim(0,max(quantile(PAHdat$PAH,0.99),100))+
  geom_vline(xintercept=50)+
  geom_vline(xintercept=100,col="red")

plot(catch_exceedence_plt)
```

```{r include=TRUE, fig.align="center", fig.cap=c("Figure 10. Probability that the sport fishery harvest exceeds 50 and 100 percent of the allowable harvest under the RMP, as well as the best estimate of the percentage of allowable impacts the sport fishery will use."),echo=FALSE}
probs<-tibble(
  parameter= c("Sport impacts / \n total (sport + tribal) \nallowable",
               "Pr. sport impacts \n > 50% of total \n (sport + tribal) allowable",
               "Pr. sport fishery \n impacts > 100% of total \n (sport + tribal) allowable"),
  probability=c(PAHdat$PAH[which(abs(PAHdat$Exceedence - 0.5)==min(abs(PAHdat$Exceedence - 0.5)))]*0.01,
                PAHdat$Exceedence[which(abs(PAHdat$PAH - 50)==min(abs(PAHdat$PAH - 50)))],
                PAHdat$Exceedence[which(abs(PAHdat$PAH - 100)==min(abs(PAHdat$PAH - 100)))]
                )
  )


risk_plt <- ggplot(probs, aes(y = probability, x = parameter)) +
  geom_bar(stat = "identity", fill = "forestgreen") +
  ylim(0, 1) +
  #coord_flip() +  # Horizontal orientation
  labs(
    y = "Probability",
    x = NULL  # Remove y-axis label
  ) +
  theme_bw()+
  geom_hline(yintercept=.50,color="red",linetype="dashed")

print(risk_plt)

```

```{r save_plts}

tag_facet <- function(p, open = "(", close = ")", tag_pool = letters, x = -Inf, y = Inf, 
                            hjust = -0.5, vjust = 1.5, fontface = 2, family = "", ...) {
        
        gb <- ggplot_build(p)
        lay <- gb$layout$layout
        tags <- cbind(lay, label = paste0(open, tag_pool[lay$PANEL], close), x = x, y = y)
        p + geom_text(data = tags, aes_string(x = "x", y = "y", label = "label"), ..., hjust = hjust, 
                      vjust = vjust, fontface = fontface, family = family, inherit.aes = FALSE) 
      }
      


daily_plt<-gridExtra::grid.arrange(
  daily_catch_plt,
  daily_effort_plt,
  daily_CPUE_plt,
  nrow=3
)
ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name),"daily_plt.png"),
       plot = daily_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name),"total_plt.png"),
       plot = total_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )



prob_management_plt<-wrap_plots(
    tag_facet(runsize_plt, tag_pool="a",x =Inf, y = Inf,
                    hjust = 1.5,
                    open="(",
                    close=")"
                    ),
    tag_facet(allowable_harvest_plt, x =Inf, y = Inf,
              tag_pool = "b",
                    hjust = 1.5,
                    open="(",
                    close=")"
                    ),
    tag_facet(catch_exceedence_plt, 
              x =Inf, 
              y = Inf,
              tag_pool = "c",
              hjust = 1.5,
              open="(",
              close=")"
              ),
    tag_facet(risk_plt, x =Inf, y = Inf,
              tag_pool = "d",
                    hjust = 1.5,
                    open="(",
                    close=")"
                    )
    )+
  plot_layout(ncol = 2) +  # Set the number of columns in the layout
  plot_layout(widths = c(3, 3), heights = c(3, 3))




ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name),"prob_management_plt.png"),
       plot = prob_management_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )
```


# Data Quantity Sensitivity analysis
```{r}

inputs_bss <- readRDS(file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_data_", params$fishery_name, ".rds")))

results<-list(NULL)
counter<-0
for(i in 1: 2){ #loop through interview and index effort data 100% = 1, 50% = 2
  tdat<-inputs_bss$Steelhead_NA_UM_Released  
  if(i==1){
    I="_I_ALL"
  }
  if(i==2){
   I="_I_EVEN"
   #Vehicle index effort counts
   V_even_indices <- which(tdat$day_V %% 2 == 0)
	 tdat$V_n<-length(V_even_indices); 
	 tdat$day_V<-tdat$day_V[V_even_indices]; 
	 tdat$section_V<-tdat$section_V[V_even_indices];  
	 tdat$countnum_V<-tdat$countnum_V[V_even_indices];
	 tdat$V_I<-tdat$V_I[V_even_indices];
	
	 #Trailer index effort counts 
	 T_even_indices <- which(tdat$day_T %% 2 == 0)
	 tdat$T_n<-length(T_even_indices);
	 tdat$day_T<-tdat$day_T[T_even_indices]; 
	 tdat$section_T<-tdat$section_T[T_even_indices];  
	 tdat$countnum_T<-tdat$countnum_T[T_even_indices];
	 tdat$T_I<-tdat$T_I[T_even_indices];
	
	#interview data - CPUE
	 IntC_even_indices <- which(tdat$day_IntC %% 2 == 0)
	 tdat$IntC<-length(IntC_even_indices);
	 tdat$day_IntC<-tdat$day_IntC[IntC_even_indices]; 
	 tdat$gear_IntC<-tdat$gear_IntC[IntC_even_indices];
	 tdat$section_IntC<-tdat$section_IntC[IntC_even_indices];  
   tdat$c<-tdat$c[IntC_even_indices];
	 tdat$h<-tdat$h[IntC_even_indices];  
	 
	#interview data - angler expansion
	 IntA_even_indices <- which(tdat$day_IntA %% 2 == 0)
	 tdat$IntA<-length(IntA_even_indices);
	 tdat$day_IntA<-tdat$day_IntA[IntA_even_indices]; 
	 tdat$gear_IntA<-tdat$gear_IntA[IntA_even_indices];
	 tdat$section_IntA<-tdat$section_IntA[IntA_even_indices];  
	 tdat$V_A<-tdat$V_A[IntA_even_indices];
	 tdat$T_A<-tdat$T_A[IntA_even_indices];
	 tdat$A_A<-tdat$A_A[IntA_even_indices];
  }
  for(j in 1:3){ #loop through census effort data 100% = 1, 60% = 2, 20% = 3
    if(j==1){
      E="_E_ALL"
      if(i==1 & j==1){
        next
      }
    }
    if(j==2){
      E="_E_135"
      E_n_1_3_5_indices<-which(tdat$day_E %in% (tdat$day_E %>% unique() %>% .[c(1, 3, 5)]))
      tdat$E_n <-length(E_n_1_3_5_indices); 
      tdat$day_E<-tdat$day_E[E_n_1_3_5_indices]
      tdat$gear_E<-tdat$gear_E[E_n_1_3_5_indices]
      tdat$section_E<-tdat$section_E[E_n_1_3_5_indices]
      tdat$countnum_E<-tdat$countnum_E[E_n_1_3_5_indices] 
      tdat$E_s<-tdat$E_s[E_n_1_3_5_indices] 
    }
    if(j==3){
      E="_E_3"
      E_n_3_indices<-which(tdat$day_E %in% (tdat$day_E %>% unique() %>% .[c(3)]))
      tdat$E_n <-length(E_n_3_indices); 
      tdat$day_E<-tdat$day_E[E_n_3_indices]
      tdat$gear_E<-tdat$gear_E[E_n_3_indices]
      tdat$section_E<-tdat$section_E[E_n_3_indices]
      tdat$countnum_E<-tdat$countnum_E[E_n_3_indices] 
      tdat$E_s<-tdat$E_s[E_n_3_indices] 
    }
    filepath<-file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_data_", params$fishery_name,I,E,".rds"))
    saveRDS(tdat,filepath)
    bss_fit_file <- file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name,I,E,".rds"))
    
    print(paste("on ",I,E))
    if (!file.exists(bss_fit_file)) {
      tryCatch({
        ecg_fit <- fit_bss(
          bss_inputs_list = readRDS(filepath),
          n_chain = 4,
          n_cores = 4,
          n_iter = 4000,
          n_warmup = 2000,
          n_thin = 1,
          adapt_delta = 0.8,
          max_treedepth = 10,
          init = "0"
        )
        saveRDS(ecg_fit, bss_fit_file)
      })
    }
    counter<-counter+1
    path<-file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name,I,E,".rds"))
    results[[counter]]<-rstan::extract(readRDS(path))
    names(results)[[counter]] = paste0(I,E)
  }
}


path<-file.path(here("fishery_analyses", params$project_name, params$fishery_name), paste0("bss_fit_", params$fishery_name,".rds"))
results[[6]]<-rstan::extract(readRDS(path))
names(results)[[6]] = paste0("_I_ALL_E_ALL")

summary_stats <- lapply(names(results), function(name) {
  x <- results[[name]]
  stats<-c("mean","sd","cv","0.025","0.25","0.50","0.75","0.975")
  totals <- tibble(
    Element = name,
    stats = stats,
    C_sum = c(mean(x$C_sum), sd(x$C_sum), sd(x$C_sum)/mean(x$C_sum), quantile(x$C_sum, c(0.025, 0.25, 0.5, 0.75, 0.975))),
    E_sum = c(mean(x$E_sum), sd(x$E_sum), sd(x$E_sum)/mean(x$E_sum), quantile(x$E_sum, c(0.025, 0.25, 0.5, 0.75, 0.975)))
  )
  return(totals)
})

# Combine the list of tibbles into a single tibble with bind_rows
summary_stats <- bind_rows(summary_stats)%>%
  mutate(I = ifelse(grepl("I_ALL",Element),"all","even"),
         E = ifelse(grepl("E_ALL",Element),5,
                    ifelse(grepl("135",Element),3,1)
         )
  )%>%
  pivot_longer(cols=c(C_sum,E_sum),names_to = "parameter",values_to = "value")%>%
  dplyr::select(-Element)%>%
  pivot_wider(names_from = stats,values_from = value)%>%
  mutate(CQV = (`0.75`-`0.25`)/(`0.75` + `0.25`))%>%
  arrange(parameter,I,desc(E))%>%
  ungroup()%>%
  group_by(parameter)%>%
  mutate(bias = ifelse(parameter=="C_sum",`0.50` / .$`0.50`[.$I == "all" & .$E == 5 & .$parameter=="C_sum"] - 1,NA),
         bias = ifelse(parameter=="E_sum" & is.na(bias),`0.50` / .$`0.50`[.$I == "all" & .$E == 5 & .$parameter=="E_sum"] -1,bias)
  )%>%
  mutate(parameter=ifelse(parameter=="C_sum","Total Catch","Total Effort"))


# Print the combined tibble
write.csv(summary_stats,file.path(here("fishery_analyses", params$project_name, params$fishery_name),"sensitivity_summary_stats.csv"),row.names = F)



CQV<-ggplot(summary_stats,aes(y=CQV,x=E,color=factor(I),group=interaction(I,parameter)))+
  facet_wrap(~parameter,ncol=2)+ # scales="free"
  scale_y_continuous(labels = scales::percent_format(),limits = c(0,NA)) +
  ylab("Precision (Coefficient of Quartile Variation)")+
  geom_point(size=3)+
  geom_bar(aes(stat="identity"))+
  xlab("")+
  geom_line()+
  labs(color = "Interview and Index \nEffort Count Days")+
  theme(strip.text = element_text(size = 14))#+
  #guides(color = "none")

CVQ2<-ggplot(summary_stats, aes_string(y = "CQV", x = "E", fill = "factor(I)", group = "interaction(I, parameter)")) +
  facet_wrap(~parameter, ncol = 2) +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, NA)) +
  ylab("Precision (Coefficient of Quartile Variation)") +
  geom_bar(stat = "identity", position = "dodge",width=0.5) +  # Separate bars by "parameter"
  xlab("") +
  labs(fill = "Interview and Index \nEffort Count Days") +  # Changed from color to fill for bars
  theme(strip.text = element_text(size = 14))



bias<-ggplot(summary_stats,aes(y=bias,x=E,color=factor(I),group=interaction(I,parameter)))+
  facet_wrap(~parameter,ncol=2)+ #scales="free"
  scale_y_continuous(labels = scales::percent_format()) +
  ylab("Bias (% Error Relative to Full Dataset)")+
  geom_bar()+
  geom_point(size=3)+
  geom_hline(yintercept = 0)+
  labs(color = "Interview and Index \nEffort Count Days")+
  xlab("Census Effort Count Flights")+
  geom_line()+
  theme(strip.text = element_text(size = 14))


bias2<-ggplot(summary_stats, aes_string(y = "bias", x = "E", fill = "factor(I)", group = "interaction(I, parameter)")) +
  facet_wrap(~parameter, ncol = 2) +
  scale_y_continuous(labels = scales::percent_format()) +
  ylab("Bias (% Error Relative to Full Dataset)")+
  geom_bar(stat = "identity", position = "dodge",width=0.5) +  # Separate bars by "parameter"
  xlab("Census Effort Count Flights")+
  labs(fill = "Interview and Index \nEffort Count Days") +  # Changed from color to fill for bars
  theme(strip.text = element_text(size = 14))+
  geom_text(aes(label=if_else(bias==0,"NA",""),color=factor(I)),hjust=1,show.legend = F)
  



power_plt<-patchwork::wrap_plots(
    tag_facet(CQV, 
              x =Inf, 
              y = Inf,
              tag_pool = c("a","b"),
              hjust = 1.5,
              open="(",
              close=")"
              ),
    tag_facet(bias, x =Inf, y = Inf,
              tag_pool = c("c","d"),
                    hjust = 1.5,
                    open="(",
                    close=")"
                    )
    )+
  plot_layout(nrow = 2) 


power_plt2<-patchwork::wrap_plots(
    tag_facet(CVQ2, 
              x =Inf, 
              y = Inf,
              tag_pool = c("a","b"),
              hjust = 1.5,
              open="(",
              close=")"
              ),
    tag_facet(bias2, x =Inf, y = Inf,
              tag_pool = c("c","d"),
                    hjust = 1.5,
                    open="(",
                    close=")"
                    )
    )+
  plot_layout(nrow = 2) 



ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name),"power_plt.png"),
       plot = power_plt,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )

ggsave(filename=file.path(here("fishery_analyses", params$project_name, params$fishery_name),"power_plt2.png"),
       plot = power_plt2,
       width = 6.5, height = 6.5, dpi = 300, limitsize = TRUE,
       scale=1.75,
       units = c("in")
       )
  

```



